#!/usr/bin/env python

import logging
import os
import shlex
import sys
import time

import rospy
import rospkg
import rosgraph
import rosgraph.names
from rosgraph.names import script_resolve_name

import roslib.packages


from roslaunch.core import setup_env, local_machine, RLException
from roslaunch.config import load_config_default
import roslaunch.xmlloader

import roslib.packages

import rosclean

import roslaunch.core
import roslaunch.config
import roslaunch.depends
from rosmaster import DEFAULT_MASTER_PORT

from roslaunch.config import load_config_default

from roslaunch.core import Node, Master, RLException

import roslaunch.config
import roslaunch.parent
import roslaunch.xmlloader 


def get_node_list(config):
    """
    @param config: roslaunch config
    @type  config: ROSLaunchConfig
    @return: list of node names in config
    @rtype: [str]
    """
    l = [_resolved_name(node) for node in config.nodes] + [_resolved_name(test) for test in config.tests]
    # filter out unnamed nodes
    return [x for x in l if x]

def print_node_list(roslaunch_files):
    """
    Print list of nodes to screen. Will cause system exit if exception
    occurs. This is a subroutine for the roslaunch main handler.

    @param roslaunch_files: list of launch files to load
    @type  roslaunch_files: str
    """
    try:
        loader = roslaunch.xmlloader.XmlLoader(resolve_anon=False)
        config = load_config_default(roslaunch_files, None, loader=loader, verbose=False, assign_machines=False)
        node_list = get_node_list(config)
        print '\n'.join(node_list)
    except RLException as e:
        print >> sys.stderr, str(e)
        sys.exit(1)

def _resolved_name(node):
    if node.name:
        # $(anon id) passthrough
        if node.name.startswith('$'):
            return node.name
        else:
            return rosgraph.names.ns_join(node.namespace, node.name)
    else:
        return None

def check_roslaunch(f):
    """
    Check roslaunch file for errors, returning error message if check fails. This routine
    is mainly to support rostest's roslaunch_check.

    :param f: roslaunch file name, ``str``
    :returns: error message or ``None``
    """
    try:
        rl_config = roslaunch.config.load_config_default([f], DEFAULT_MASTER_PORT, verbose=False)
    except roslaunch.core.RLException as e:
        return str(e)
    
    errors = []
    # check for missing deps
    base_pkg, file_deps, missing = roslaunch.depends.roslaunch_deps([f])
    for pkg, miss in missing.iteritems():
        if miss:
            errors.append("Missing manifest dependencies: %s/manifest.xml: %s"%(pkg, ', '.join(miss)))
    
    # load all node defs
    nodes = []
    for filename, rldeps in file_deps.iteritems():
        nodes.extend(rldeps.nodes)

    # check for missing packages
    rospack = rospkg.RosPack()
    for pkg, node_type in nodes:
        try:
            rospack.get_path(pkg)
        except:
            errors.append("cannot find package [%s] for node [%s]"%(pkg, node_type))

    # check for missing nodes
    for pkg, node_type in nodes:
        try:
            if not roslib.packages.find_node(pkg, node_type):
                errors.append("cannot find node [%s] in package [%s]"%(node_type, pkg))
        except Exception as e:
            errors.append("unable to find node [%s/%s]: %s"%(pkg, node_type, str(e)))
                
    # Check for configuration errors, #2889
    for err in rl_config.config_errors:
        errors.append('ROSLaunch config error: %s' % err)

    if errors:
        return '\n'.join(errors)

if __name__ == '__main__':
	f = '/home/phuicy/catkin_ws/src/dynamic/launch/q_p_talk.launch'
	lit = [f]
	#print_node_list(lit)
	#print check_roslaunch(f)

 	#import rosgraph.masterapi
       # master = rosgraph.masterapi.Master('/roslaunch_script')
      #  uuid = master.getParam('/run_id')
     #   parent = roslaunch.parent.ROSLaunchParent(uuid, f, is_core=False)
	config = load_config_default(lit,None)
	#print config.summary()
	lip = config.nodes

	node = lip[0]

	#import roslaunch.scriptapi as art
	#aft = art.ROSLaunch()
	#aft.start()
	#aft.launch(node)
	#aft.spin()
	
	masterURI = rosgraph.get_master_uri()

	import roslaunch.nodeprocess as np
	proc = np.create_node_process('asdq', node, masterURI)
	proc.start()
	
	rospy.wait(2)
	
	proc.stop()
	


